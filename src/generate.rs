mod builder;

use crate::MethodsToMockStrategy;
use crate::model;

// Generator for gmock mocks. Generates mock code for a single class or complete headers
// for a set of classes.
pub(crate) struct Generator {
    methods_to_mock: MethodsToMockStrategy,
    add_deprecation_pragma: bool,
    simplified_nested_namespaces: bool,
    indent_str: String,
}

impl crate::Mock {
    fn from(parent: &model::ClassToMock, name: &str, builder: builder::CodeBuilder) -> Self {
        Self {
            source_file: None,
            parent_name: parent.name.clone(),
            name: name.to_string(),
            code: builder.build(),
        }
    }
}

impl crate::MockHeader {
    fn new() -> Self {
        Self {
            source_files: Vec::new(),
            parent_names: Vec::new(),
            names: Vec::new(),
            code: String::new(),
        }
    }
}

impl Generator {
    pub(crate) fn new(methods_to_mock: MethodsToMockStrategy) -> Self {
        Self {
            methods_to_mock,
            add_deprecation_pragma: false,
            simplified_nested_namespaces: true,
            indent_str: "  ".to_string(),
        }
    }

    pub(crate) fn methods_to_mock(&mut self, functions: MethodsToMockStrategy) {
        self.methods_to_mock = functions;
    }

    pub(crate) fn add_deprecation_pragma(&mut self, value: bool) {
        self.add_deprecation_pragma = value;
    }

    pub(crate) fn simplified_nested_namespaces(&mut self, value: bool) {
        self.simplified_nested_namespaces = value;
    }

    pub(crate) fn indent_str(&mut self, indent_str: String) {
        self.indent_str = indent_str;
    }

    pub(crate) fn header(
        &self,
        source_file_paths: &[String],
        classes: &[model::ClassToMock],
        mock_names: &[String],
    ) -> crate::MockHeader {
        let mut builder = builder::CodeBuilder::new(self.indent_str.clone());
        builder.add_line(
            "// Automatically generated by Mocksmith (https://github.com/jordfras/mocksmith)",
        );
        builder.add_line("#pragma once");
        builder.add_line("");
        for path in source_file_paths {
            builder.add_line(&format!("#include \"{path}\""));
        }
        builder.add_line("#include <gmock/gmock.h>");

        if self.add_deprecation_pragma {
            builder.add_line("");
            builder.add_line("#ifdef _MSC_VER");
            builder.add_line(&format!("#{}pragma warning(push)", self.indent_str));
            builder.add_line(&format!(
                "#{}pragma warning(disable : 4996)",
                self.indent_str
            ));
            builder.add_line("#endif");
        }

        let mut header = crate::MockHeader::new();
        for (class, mock_name) in classes.iter().zip(mock_names) {
            builder.add_line("");
            self.build_mock(&mut builder, class, mock_name);
            header.parent_names.push(class.name.clone());
            header.names.push(mock_name.clone());
        }

        if self.add_deprecation_pragma {
            builder.add_line("");
            builder.add_line("#ifdef _MSC_VER");
            builder.add_line(&format!("#{}pragma warning(pop)", self.indent_str));
            builder.add_line("#endif");
        }

        header.code = builder.build();
        header
    }

    pub(crate) fn mock(&self, class: &model::ClassToMock, mock_name: &str) -> crate::Mock {
        let mut builder = builder::CodeBuilder::new(self.indent_str.clone());
        self.build_mock(&mut builder, class, mock_name);
        crate::Mock::from(class, mock_name, builder)
    }

    fn build_mock(
        &self,
        builder: &mut builder::CodeBuilder,
        class: &model::ClassToMock,
        mock_name: &str,
    ) {
        builder.maybe_add_line(&self.namespace_start(&class.namespaces));

        builder.add_line(&format!("class {} : public {}", mock_name, class.name));
        builder.add_line("{");
        builder.add_line("public:");
        builder.push_indent();
        class.methods.iter().for_each(|method| {
            builder.add_line(&format!(
                "MOCK_METHOD({}, {}, ({}), ({}));",
                method_return_type(method),
                method.name,
                method_arguments(method).join(", "),
                method_qualifiers(method).join(", ")
            ));
        });
        builder.pop_indent();
        builder.add_line("};");

        builder.maybe_add_line(&self.namespace_end(&class.namespaces));
    }

    fn namespace_start(&self, namespaces: &[String]) -> Option<String> {
        if namespaces.is_empty() {
            None
        } else if self.simplified_nested_namespaces {
            Some(format!("namespace {} {{", namespaces.join("::")))
        } else {
            Some(
                namespaces
                    .iter()
                    .map(|namespace| format!("namespace {namespace} {{"))
                    .collect::<Vec<_>>()
                    .join(" "),
            )
        }
    }

    fn namespace_end(&self, namespaces: &[String]) -> Option<String> {
        if namespaces.is_empty() {
            None
        } else if self.simplified_nested_namespaces {
            Some("}".to_string())
        } else {
            Some("}".repeat(namespaces.len()))
        }
    }
}

fn wrap_with_parentheses_if_contains_comma(return_type_or_arg: &str) -> String {
    if return_type_or_arg.contains(',') {
        format!("({return_type_or_arg})")
    } else {
        return_type_or_arg.to_string()
    }
}

fn method_return_type(method: &model::MethodToMock) -> String {
    wrap_with_parentheses_if_contains_comma(&method.result_type)
}

fn method_arguments(method: &model::MethodToMock) -> Vec<String> {
    method
        .arguments
        .iter()
        .map(|arg| {
            if let Some(arg_name) = &arg.name {
                format!("{} {}", arg.type_name, arg_name)
            } else {
                arg.type_name.clone()
            }
        })
        .map(|arg_str| wrap_with_parentheses_if_contains_comma(&arg_str))
        .collect()
}

fn method_qualifiers(method: &model::MethodToMock) -> Vec<String> {
    let mut qualifiers = Vec::new();
    if method.is_const {
        qualifiers.push("const".to_string());
    }
    if let Some(rq) = &method.ref_qualifier {
        qualifiers.push(format!("ref({rq})"));
    }
    if method.is_noexcept {
        qualifiers.push("noexcept".to_string());
    }
    if method.is_virtual {
        qualifiers.push("override".to_string());
    }
    qualifiers
}
