mod builder;

use crate::MethodsToMockStrategy;
use crate::model;

// Generator for gmock mocks. Generates mock code for a single class or complete headers
// for a set of classes.
pub(crate) struct Generator {
    methods_to_mock: MethodsToMockStrategy,
    simplified_nested_namespaces: bool,
    indent_str: String,
}

impl Generator {
    pub(crate) fn new(methods_to_mock: MethodsToMockStrategy) -> Self {
        Self {
            methods_to_mock,
            simplified_nested_namespaces: true,
            indent_str: "  ".to_string(),
        }
    }

    pub(crate) fn methods_to_mock(&mut self, functions: MethodsToMockStrategy) {
        self.methods_to_mock = functions;
    }

    pub(crate) fn simplified_nested_namespaces(&mut self, value: bool) {
        self.simplified_nested_namespaces = value;
    }

    pub(crate) fn indent_str(&mut self, indent_str: String) {
        self.indent_str = indent_str;
    }

    pub(crate) fn header(
        &self,
        interface_header_path: &str,
        classes: &[model::ClassToMock],
        mock_names: &[String],
    ) -> String {
        let mut builder = builder::CodeBuilder::new(self.indent_str.clone());
        builder.add_line(
            "// Automatically generated by Mocksmith (https://github.com/jordfras/mocksmith)",
        );
        builder.add_line("#pragma once");
        builder.add_line("");
        builder.add_line("#include <gmock/gmock.h>");
        builder.add_line(&format!("#include \"{interface_header_path}\""));
        builder.add_line("");

        for (class, mock_name) in classes.iter().zip(mock_names) {
            self.build_mock(&mut builder, class, mock_name);
            builder.add_line("");
        }

        builder.build()
    }

    pub(crate) fn mock(&self, class: &model::ClassToMock, mock_name: &str) -> String {
        let mut builder = builder::CodeBuilder::new(self.indent_str.clone());
        self.build_mock(&mut builder, class, mock_name);
        builder.build()
    }

    fn build_mock(
        &self,
        builder: &mut builder::CodeBuilder,
        class: &model::ClassToMock,
        mock_name: &str,
    ) {
        builder.maybe_add_line(&self.namespace_start(&class.namespaces));

        builder.add_line(&format!(
            "class {} : public {}",
            mock_name,
            class.class.get_name().unwrap()
        ));
        builder.add_line("{");
        builder.add_line("public:");
        builder.push_indent();
        class
            .methods()
            .iter()
            .filter(|method| self.methods_to_mock.should_mock(method))
            .for_each(|method| {
                builder.add_line(&format!(
                    "MOCK_METHOD({}, {}, ({}), ({}));",
                    method_return_type(method),
                    method.get_name().expect("Method should have a name"),
                    method_arguments(method).join(", "),
                    method_qualifiers(method).join(", ")
                ));
            });
        builder.pop_indent();
        builder.add_line("};");

        builder.maybe_add_line(&self.namespace_end(&class.namespaces));
    }

    fn namespace_start(&self, namespaces: &[clang::Entity]) -> Option<String> {
        if namespaces.is_empty() {
            None
        } else if self.simplified_nested_namespaces {
            Some(format!(
                "namespace {} {{",
                namespaces
                    .iter()
                    .map(|namespace| namespace.get_name().expect("Namespace should have a name"))
                    .collect::<Vec<_>>()
                    .join("::")
            ))
        } else {
            Some(
                namespaces
                    .iter()
                    .map(|namespace| {
                        format!(
                            "namespace {} {{",
                            namespace.get_name().expect("Namespace should have a name")
                        )
                    })
                    .collect::<Vec<_>>()
                    .join(" "),
            )
        }
    }

    fn namespace_end(&self, namespaces: &[clang::Entity]) -> Option<String> {
        if namespaces.is_empty() {
            None
        } else if self.simplified_nested_namespaces {
            Some("}".to_string())
        } else {
            Some("}".repeat(namespaces.len()))
        }
    }
}

fn wrap_with_parentheses_if_contains_comma(return_type_or_arg: String) -> String {
    if return_type_or_arg.contains(',') {
        format!("({return_type_or_arg})")
    } else {
        return_type_or_arg.to_string()
    }
}

fn method_return_type(method: &clang::Entity) -> String {
    wrap_with_parentheses_if_contains_comma(
        method
            .get_result_type()
            .expect("Method should have a return type")
            .get_display_name(),
    )
}

fn method_arguments(method: &clang::Entity) -> Vec<String> {
    method
        .get_arguments()
        .expect("Method should have arguments")
        .iter()
        .map(|arg| {
            let type_name = arg
                .get_type()
                .expect("Argument should have a type")
                .get_display_name();
            if let Some(arg_name) = arg.get_name() {
                format!("{} {}", type_name, arg_name)
            } else {
                type_name
            }
        })
        .map(wrap_with_parentheses_if_contains_comma)
        .collect()
}

fn method_qualifiers(method: &clang::Entity) -> Vec<String> {
    let mut qualifiers = Vec::new();
    if method.is_const_method() {
        qualifiers.push("const".to_string());
    }
    if let Some(exception_specification) = method.get_exception_specification() {
        if exception_specification == clang::ExceptionSpecification::BasicNoexcept {
            qualifiers.push("noexcept".to_string());
        }
    }
    if method.is_virtual_method() {
        qualifiers.push("override".to_string());
    }
    qualifiers
}
